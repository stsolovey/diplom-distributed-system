# Техническое задание: Интеграция NATS JetStream (Фаза 2)

## Общее описание задачи

Необходимо заменить текущую in-memory очередь на NATS JetStream, сохранив при этом обратную совместимость через существующие интерфейсы. Это позволит системе работать с персистентными сообщениями и обеспечит отказоустойчивость.

## Детальный план реализации

### 1. Подготовка окружения

**Файл для изменения**: `docker/docker-compose.yml`

Добавить новый сервис NATS после существующих сервисов:

```yaml
  nats:
    image: nats:2.10-alpine
    command: "-js -m 8222"
    ports:
      - "4222:4222"
      - "8222:8222"
    healthcheck:
      test: ["CMD", "nc", "-z", "localhost", "4222"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - diplom-net
    volumes:
      - nats-data:/data
```

И в конце файла добавить volume:
```yaml
volumes:
  nats-data:
```

### 2. Добавление зависимости NATS

**Файл**: `go.mod`

Выполнить команду:
```bash
go get github.com/nats-io/nats.go@v1.36.0
```

### 3. Создание NATS брокера

**Новый файл**: `internal/queue/nats_broker.go`

```go
package queue

import (
    "context"
    "fmt"
    "time"
    
    "github.com/nats-io/nats.go"
    "github.com/nats-io/nats.go/jetstream"
)

type NATSBroker struct {
    nc     *nats.Conn
    js     jetstream.JetStream
    config NATSConfig
}

type NATSConfig struct {
    URL             string
    StreamName      string
    SubjectPrefix   string
    MaxReconnects   int
    ReconnectWait   time.Duration
}

// NewNATSBroker создает новое подключение к NATS
func NewNATSBroker(cfg NATSConfig) (*NATSBroker, error) {
    opts := []nats.Option{
        nats.MaxReconnects(cfg.MaxReconnects),
        nats.ReconnectWait(cfg.ReconnectWait),
        nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {
            if err != nil {
                log.Printf("NATS disconnected: %v", err)
            }
        }),
        nats.ReconnectHandler(func(nc *nats.Conn) {
            log.Printf("NATS reconnected to %s", nc.ConnectedUrl())
        }),
    }
    
    nc, err := nats.Connect(cfg.URL, opts...)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to NATS: %w", err)
    }
    
    js, err := jetstream.New(nc)
    if err != nil {
        nc.Close()
        return nil, fmt.Errorf("failed to create JetStream context: %w", err)
    }
    
    broker := &NATSBroker{
        nc:     nc,
        js:     js,
        config: cfg,
    }
    
    // Создаем stream если не существует
    if err := broker.ensureStream(); err != nil {
        nc.Close()
        return nil, err
    }
    
    return broker, nil
}

// ensureStream создает JetStream stream если он не существует
func (b *NATSBroker) ensureStream() error {
    stream, err := b.js.Stream(context.Background(), b.config.StreamName)
    if err == nil {
        // Stream уже существует
        log.Printf("Using existing stream: %s", b.config.StreamName)
        return nil
    }
    
    // Создаем новый stream
    cfg := jetstream.StreamConfig{
        Name:      b.config.StreamName,
        Subjects:  []string{b.config.SubjectPrefix + ".>"},
        Retention: jetstream.WorkQueuePolicy,
        MaxAge:    24 * time.Hour,
        MaxMsgs:   1000000,
        Storage:   jetstream.FileStorage,
    }
    
    _, err = b.js.CreateStream(context.Background(), cfg)
    if err != nil {
        return fmt.Errorf("failed to create stream: %w", err)
    }
    
    log.Printf("Created new stream: %s", b.config.StreamName)
    return nil
}

// Close закрывает соединение с NATS
func (b *NATSBroker) Close() error {
    return b.nc.Close()
}
```

### 4. Реализация NATS Publisher

**Новый файл**: `internal/queue/nats_publisher.go`

```go
package queue

import (
    "context"
    "encoding/json"
    "fmt"
    
    "github.com/nats-io/nats.go/jetstream"
    "github.com/stsolovey/diplom-distributed-system/internal/models"
)

type NATSPublisher struct {
    js      jetstream.JetStream
    subject string
}

// NewNATSPublisher создает publisher для конкретного subject
func NewNATSPublisher(broker *NATSBroker, subject string) *NATSPublisher {
    return &NATSPublisher{
        js:      broker.js,
        subject: broker.config.SubjectPrefix + "." + subject,
    }
}

// Publish отправляет сообщение в NATS JetStream
func (p *NATSPublisher) Publish(ctx context.Context, msg *models.DataMessage) error {
    data, err := json.Marshal(msg)
    if err != nil {
        return fmt.Errorf("failed to marshal message: %w", err)
    }
    
    // Публикуем с acknowledgment для гарантии доставки
    ack, err := p.js.Publish(ctx, p.subject, data)
    if err != nil {
        return fmt.Errorf("failed to publish message: %w", err)
    }
    
    // Ждем подтверждения от JetStream
    select {
    case <-ctx.Done():
        return ctx.Err()
    case <-ack.Done():
        if ack.Err() != nil {
            return fmt.Errorf("publish acknowledgment error: %w", ack.Err())
        }
    }
    
    return nil
}
```

### 5. Реализация NATS Subscriber

**Новый файл**: `internal/queue/nats_subscriber.go`

```go
package queue

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "time"
    
    "github.com/nats-io/nats.go/jetstream"
    "github.com/stsolovey/diplom-distributed-system/internal/models"
)

type NATSSubscriber struct {
    js       jetstream.JetStream
    subject  string
    consumer jetstream.Consumer
}

// NewNATSSubscriber создает subscriber для конкретного subject
func NewNATSSubscriber(broker *NATSBroker, subject string) (*NATSSubscriber, error) {
    fullSubject := broker.config.SubjectPrefix + "." + subject
    
    // Создаем durable consumer
    cfg := jetstream.ConsumerConfig{
        Name:          subject + "-consumer",
        Durable:       subject + "-consumer",
        FilterSubject: fullSubject,
        AckPolicy:     jetstream.AckExplicitPolicy,
        MaxDeliver:    3,
        AckWait:       30 * time.Second,
    }
    
    consumer, err := broker.js.CreateOrUpdateConsumer(
        context.Background(),
        broker.config.StreamName,
        cfg,
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create consumer: %w", err)
    }
    
    return &NATSSubscriber{
        js:       broker.js,
        subject:  fullSubject,
        consumer: consumer,
    }, nil
}

// Subscribe создает канал для получения сообщений
func (s *NATSSubscriber) Subscribe(ctx context.Context) (<-chan *models.DataMessage, error) {
    msgChan := make(chan *models.DataMessage, 100)
    
    // Создаем pull subscription с back-pressure
    iter, err := s.consumer.Messages(
        jetstream.WithMessagesContext(ctx),
        jetstream.PullMaxMessages(10), // back-pressure: получаем max 10 сообщений за раз
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create message iterator: %w", err)
    }
    
    // Горутина для чтения сообщений
    go func() {
        defer close(msgChan)
        
        for {
            select {
            case <-ctx.Done():
                iter.Stop()
                return
            default:
                msg, err := iter.Next()
                if err != nil {
                    if err == context.Canceled {
                        return
                    }
                    log.Printf("Error fetching message: %v", err)
                    time.Sleep(time.Second) // back-off при ошибках
                    continue
                }
                
                // Десериализуем сообщение
                var dataMsg models.DataMessage
                if err := json.Unmarshal(msg.Data(), &dataMsg); err != nil {
                    log.Printf("Failed to unmarshal message: %v", err)
                    msg.Nak() // negative acknowledgment
                    continue
                }
                
                // Отправляем в канал
                select {
                case msgChan <- &dataMsg:
                    // Подтверждаем только после успешной отправки в канал
                    if err := msg.Ack(); err != nil {
                        log.Printf("Failed to ack message: %v", err)
                    }
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    
    return msgChan, nil
}

// Close останавливает подписку
func (s *NATSSubscriber) Close() error {
    // Consumer автоматически очищается при закрытии соединения
    return nil
}
```

### 6. Создание адаптера для NATS

**Новый файл**: `internal/queue/nats_adapter.go`

```go
package queue

import (
    "context"
    "sync"
    
    "github.com/stsolovey/diplom-distributed-system/internal/models"
)

// NATSQueueAdapter адаптирует NATS для работы через существующие интерфейсы
type NATSQueueAdapter struct {
    broker     *NATSBroker
    publisher  *NATSPublisher
    subscriber *NATSSubscriber
    stats      QueueStats
    statsMu    sync.RWMutex
}

// NewNATSQueueAdapter создает новый адаптер для NATS
func NewNATSQueueAdapter(natsURL string) (QueueProvider, error) {
    cfg := NATSConfig{
        URL:           natsURL,
        StreamName:    "DIPLOM_STREAM",
        SubjectPrefix: "diplom",
        MaxReconnects: -1, // бесконечные переподключения
        ReconnectWait: 2 * time.Second,
    }
    
    broker, err := NewNATSBroker(cfg)
    if err != nil {
        return nil, err
    }
    
    publisher := NewNATSPublisher(broker, "messages")
    
    subscriber, err := NewNATSSubscriber(broker, "messages")
    if err != nil {
        broker.Close()
        return nil, err
    }
    
    return &NATSQueueAdapter{
        broker:     broker,
        publisher:  publisher,
        subscriber: subscriber,
    }, nil
}

// Publish реализует интерфейс Publisher
func (a *NATSQueueAdapter) Publish(ctx context.Context, msg *models.DataMessage) error {
    err := a.publisher.Publish(ctx, msg)
    if err == nil {
        a.statsMu.Lock()
        a.stats.TotalEnqueued++
        a.statsMu.Unlock()
    }
    return err
}

// Subscribe реализует интерфейс Subscriber
func (a *NATSQueueAdapter) Subscribe(ctx context.Context) (<-chan *models.DataMessage, error) {
    msgChan, err := a.subscriber.Subscribe(ctx)
    if err != nil {
        return nil, err
    }
    
    // Обертка для подсчета статистики
    wrappedChan := make(chan *models.DataMessage, 100)
    go func() {
        defer close(wrappedChan)
        for msg := range msgChan {
            a.statsMu.Lock()
            a.stats.TotalDequeued++
            a.statsMu.Unlock()
            
            select {
            case wrappedChan <- msg:
            case <-ctx.Done():
                return
            }
        }
    }()
    
    return wrappedChan, nil
}

// Stats возвращает статистику
func (a *NATSQueueAdapter) Stats() QueueStats {
    a.statsMu.RLock()
    defer a.statsMu.RUnlock()
    stats := a.stats
    // CurrentSize не применим для NATS
    stats.CurrentSize = -1
    return stats
}

// Close закрывает все ресурсы
func (a *NATSQueueAdapter) Close() error {
    if err := a.subscriber.Close(); err != nil {
        return err
    }
    return a.broker.Close()
}
```

### 7. Добавление фабрики для выбора типа очереди

**Изменить файл**: `internal/config/config.go`

Добавить новые поля в структуру Config:

```go
type Config struct {
    // ... существующие поля ...
    
    // Queue settings
    QueueType string // "memory" или "nats"
    NATSURL   string // URL для подключения к NATS
}

func LoadConfig() *Config {
    return &Config{
        // ... существующие поля ...
        
        QueueType: getEnv("QUEUE_TYPE", "memory"),
        NATSURL:   getEnv("NATS_URL", "nats://localhost:4222"),
    }
}
```

### 8. Создание фабрики очередей

**Новый файл**: `internal/queue/factory.go`

```go
package queue

import (
    "fmt"
    "log"
)

// CreateQueueProvider создает провайдер очереди на основе конфигурации
func CreateQueueProvider(queueType string, queueSize int, natsURL string) (QueueProvider, error) {
    switch queueType {
    case "memory":
        log.Println("Using in-memory queue")
        return NewMemoryQueueAdapter(queueSize), nil
        
    case "nats":
        log.Printf("Using NATS JetStream queue at %s", natsURL)
        provider, err := NewNATSQueueAdapter(natsURL)
        if err != nil {
            return nil, fmt.Errorf("failed to create NATS adapter: %w", err)
        }
        return provider, nil
        
    default:
        return nil, fmt.Errorf("unknown queue type: %s", queueType)
    }
}
```

### 9. Модификация Processor для работы с новым интерфейсом

**Изменить файл**: `internal/processor/worker_pool.go`

Заменить поле `queue *queue.MemoryQueue` на `subscriber queue.Subscriber`:

```go
type WorkerPool struct {
    workers    int
    subscriber queue.Subscriber  // изменено с *queue.MemoryQueue
    wg         sync.WaitGroup
    results    chan *models.ProcessingResult
    stats      Stats
    statsMu    sync.RWMutex
}

// NewWorkerPool создает новый пул воркеров
func NewWorkerPool(workers int, subscriber queue.Subscriber) *WorkerPool {
    return &WorkerPool{
        workers:    workers,
        subscriber: subscriber,
        results:    make(chan *models.ProcessingResult, workers*2),
    }
}

// runWorker - изменить метод получения сообщений
func (wp *WorkerPool) runWorker(ctx context.Context, workerID int) {
    defer wp.wg.Done()
    log.Printf("Worker %d started", workerID)
    
    // Получаем канал сообщений
    msgChan, err := wp.subscriber.Subscribe(ctx)
    if err != nil {
        log.Printf("Worker %d failed to subscribe: %v", workerID, err)
        return
    }
    
    for {
        select {
        case msg, ok := <-msgChan:
            if !ok {
                log.Printf("Worker %d stopping - channel closed", workerID)
                return
            }
            
            result := wp.processMessage(msg)
            
            select {
            case wp.results <- result:
            case <-ctx.Done():
                log.Printf("Worker %d stopping", workerID)
                return
            }
            
        case <-ctx.Done():
            log.Printf("Worker %d stopping", workerID)
            return
        }
    }
}
```

### 10. Обновление main файлов сервисов

**Изменить файл**: `cmd/processor/main.go`

```go
package main

import (
    // ... imports ...
    "github.com/stsolovey/diplom-distributed-system/internal/queue"
)

var (
    queueProvider queue.QueueProvider  // изменено
    pool          *processor.WorkerPool
)

func main() {
    cfg := config.LoadConfig()
    
    // Создаем провайдер очереди через фабрику
    provider, err := queue.CreateQueueProvider(
        cfg.QueueType,
        cfg.QueueSize,
        cfg.NATSURL,
    )
    if err != nil {
        log.Fatalf("Failed to create queue provider: %v", err)
    }
    queueProvider = provider
    
    // Создаем worker pool с subscriber
    pool = processor.NewWorkerPool(cfg.ProcessorWorkers, queueProvider)
    
    // ... остальной код без изменений ...
}

// handleEnqueue - изменить для использования Publisher интерфейса
func handleEnqueue(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    var msg models.DataMessage
    if err := json.NewDecoder(r.Body).Decode(&msg); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }
    
    ctx := r.Context()
    if err := queueProvider.Publish(ctx, &msg); err != nil {
        // Обработка ошибок остается той же
        if err == queue.ErrQueueFull {
            http.Error(w, "Queue is full", http.StatusServiceUnavailable)
        } else {
            http.Error(w, "Failed to enqueue message", http.StatusInternalServerError)
        }
        return
    }
    
    w.WriteHeader(http.StatusAccepted)
}

// handleStats - обновить для использования QueueProvider
func handleStats(w http.ResponseWriter, r *http.Request) {
    poolStats := pool.GetStats()
    queueStats := queueProvider.Stats()  // изменено
    
    stats := map[string]interface{}{
        "queue": queueStats,
        "pool":  poolStats,
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(stats)
}
```

### 11. Обновление тестов

**Изменить файл**: `internal/processor/worker_pool_test.go`

Добавить тест для NATS:

```go
func TestWorkerPool_WithNATS(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping NATS integration test")
    }
    
    // Требует запущенного NATS
    provider, err := queue.NewNATSQueueAdapter("nats://localhost:4222")
    if err != nil {
        t.Skipf("NATS not available: %v", err)
    }
    defer provider.Close()
    
    pool := NewWorkerPool(2, provider)
    
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    pool.Start(ctx)
    
    // Отправляем тестовые сообщения
    for i := 0; i < 5; i++ {
        msg := &models.DataMessage{
            Id:      fmt.Sprintf("nats-test-%d", i),
            Payload: []byte(fmt.Sprintf("nats-data-%d", i)),
        }
        if err := provider.Publish(ctx, msg); err != nil {
            t.Fatalf("Failed to publish: %v", err)
        }
    }
    
    // Проверяем обработку
    timeout := time.After(5 * time.Second)
    for {
        select {
        case <-timeout:
            t.Fatal("Timeout waiting for processing")
        case <-time.After(100 * time.Millisecond):
            stats := pool.GetStats()
            if stats.ProcessedCount >= 5 {
                return
            }
        }
    }
}
```

### 12. Обновление docker-compose для связи сервисов

**Изменить файл**: `docker/docker-compose.yml`

Добавить environment переменные и depends_on:

```yaml
services:
  processor:
    # ... существующая конфигурация ...
    environment:
      - PROCESSOR_PORT=8082
      - PROCESSOR_WORKERS=4
      - QUEUE_SIZE=1000
      - QUEUE_TYPE=${QUEUE_TYPE:-memory}  # по умолчанию memory
      - NATS_URL=nats://nats:4222
    depends_on:
      nats:
        condition: service_healthy
```

### 13. Создание скрипта для переключения между типами очередей

**Новый файл**: `scripts/switch-queue.sh`

```bash
#!/bin/bash

QUEUE_TYPE=${1:-memory}

echo "Switching to $QUEUE_TYPE queue..."

# Экспортируем переменную
export QUEUE_TYPE=$QUEUE_TYPE

# Перезапускаем сервисы
docker-compose -f docker/docker-compose.yml down
docker-compose -f docker/docker-compose.yml up -d

echo "Waiting for services to start..."
sleep 10

# Проверяем здоровье
./scripts/test-system.sh

echo "Queue switched to $QUEUE_TYPE"
```

## Критерии приемки

1. **Функциональные требования**:
   - [ ] Система работает как с memory, так и с NATS очередью
   - [ ] Переключение между типами очередей через переменную окружения
   - [ ] Сообщения не теряются при переключении на NATS
   - [ ] Back-pressure работает (при переполнении NATS отдает ошибку)

2. **Нефункциональные требования**:
   - [ ] Все существующие тесты проходят
   - [ ] Добавлены integration тесты для NATS
   - [ ] Документация обновлена
   - [ ] Нет деградации производительности

3. **Проверка back-pressure**:
   - [ ] При остановке воркеров сообщения накапливаются в NATS
   - [ ] При возобновлении работы сообщения обрабатываются
   - [ ] Нет OOM при большом количестве сообщений

## Тестирование

```bash
# 1. Запуск с memory очередью
make docker-up
make integration-test

# 2. Переключение на NATS
./scripts/switch-queue.sh nats
make integration-test

# 3. Нагрузочное тестирование
make load-test

# 4. Проверка персистентности (остановить processor, отправить сообщения, запустить processor)
docker-compose stop processor
./scripts/test-system.sh  # отправит сообщение
docker-compose start processor
# Проверить что сообщение обработано через /stats
```

## Возможные проблемы и решения

1. **NATS не успевает запуститься**:
   - Увеличить `start_period` в healthcheck
   - Добавить retry логику в NewNATSBroker

2. **Timeout при publish**:
   - Проверить сетевую связность между контейнерами
   - Увеличить AckWait в ConsumerConfig

3. **Потеря сообщений**:
   - Убедиться что используется AckExplicitPolicy
   - Проверить что Ack вызывается после успешной обработки

4. **Производительность ниже ожидаемой**:
   - Увеличить PullMaxMessages для батчинга
   - Настроить количество горутин в Subscribe

## Дополнительные материалы

- [NATS JetStream Documentation](https://docs.nats.io/nats-concepts/jetstream)
- [nats.go Client Examples](https://github.com/nats-io/nats.go/tree/main/examples)
- [JetStream Best Practices](https://docs.nats.io/using-nats/developer/develop_jetstream)

**TL;DR**: Необходимо добавить NATS JetStream как альтернативу in-memory очереди, сохранив возможность переключения через конфигурацию. Основная сложность - правильная обработка acknowledgments и реализация back-pressure через pull-based подписку.