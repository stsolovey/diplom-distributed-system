# üìã –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –∑–∞–¥–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –§–∞–∑—ã 3: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ

**–í–µ—Ä—Å–∏—è**: 2.0  
**–î–∞—Ç–∞**: 13 –∏—é–Ω—è 2025  
**–°—Ç–∞—Ç—É—Å**: –ö –ò–°–ü–û–õ–ù–ï–ù–ò–Æ  
**Deadline**: 

## üéØ –¶–µ–ª—å —Ñ–∞–∑—ã

–ó–∞–≤–µ—Ä—à–∏—Ç—å –≤—Å–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∏ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã, –ø–æ–¥–≥–æ—Ç–æ–≤–∏–≤ –µ—ë –∫ –Ω–∞–≥—Ä—É–∑–æ—á–Ω–æ–º—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é –≤ –§–∞–∑–µ 4.

## üìä –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å

- **–®–∞–≥ 6 (–ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ)**: 65% –≤—ã–ø–æ–ª–Ω–µ–Ω
- **–®–∞–≥ 7 (–°–µ—Ç–µ–≤—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏)**: 0% –≤—ã–ø–æ–ª–Ω–µ–Ω
- **–û–±—â–∏–π –ø—Ä–æ–≥—Ä–µ—Å—Å –§–∞–∑—ã 3**: 33%

## üîß –î–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —Ä–∞–±–æ—Ç

### –®–∞–≥ 6: –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏—è

#### 6.1 –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ BenchmarkWorkerPool

**–§–∞–π–ª**: `internal/processor/worker_pool_test.go`

```go
package processor

import (
    "context"
    "fmt"
    "sync"
    "testing"
    "time"
    
    "github.com/stsolovey/diplom-distributed-system/internal/models"
    "github.com/stsolovey/diplom-distributed-system/internal/queue"
)

func BenchmarkWorkerPool(b *testing.B) {
    // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å –æ—Ç–º–µ–Ω–æ–π
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // –°–æ–∑–¥–∞–µ–º –æ—á–µ—Ä–µ–¥—å –∏ –ø—É–ª
    queueSize := b.N
    if queueSize < 1000 {
        queueSize = 1000
    }
    
    memQueue := queue.NewMemoryAdapter(queueSize)
    pool := NewWorkerPool(4, memQueue)
    
    // –ü—Ä–µ–¥–∑–∞–ø–æ–ª–Ω—è–µ–º –æ—á–µ—Ä–µ–¥—å
    for i := 0; i < b.N; i++ {
        msg := &models.DataMessage{
            Id:        fmt.Sprintf("bench-%d", i),
            Timestamp: time.Now().Unix(),
            Source:    "benchmark",
            Payload:   []byte("test payload for benchmarking"),
        }
        if err := memQueue.Publish(ctx, msg); err != nil {
            b.Fatalf("Failed to enqueue: %v", err)
        }
    }
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—É–ª
    if err := pool.Start(ctx); err != nil {
        b.Fatalf("Failed to start pool: %v", err)
    }
    
    // –°–±—Ä–æ—Å —Ç–∞–π–º–µ—Ä–∞ –ø–æ—Å–ª–µ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏
    b.ResetTimer()
    
    // –°—á–∏—Ç–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    var processed int
    var mu sync.Mutex
    done := make(chan struct{})
    
    go func() {
        for range pool.Results() {
            mu.Lock()
            processed++
            if processed >= b.N {
                close(done)
                mu.Unlock()
                return
            }
            mu.Unlock()
        }
    }()
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    select {
    case <-done:
        // –£—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–ª–∏ –≤—Å–µ
    case <-time.After(30 * time.Second):
        mu.Lock()
        b.Fatalf("Timeout: processed only %d/%d messages", processed, b.N)
        mu.Unlock()
    }
    
    b.StopTimer()
    
    // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É–ª
    cancel()
    pool.Stop()
    
    // –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
    b.Logf("Processed %d messages", b.N)
}
```

#### 6.2 –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

**–°–∫—Ä–∏–ø—Ç**: `scripts/complete_profiling.sh`

```bash
#!/bin/bash
set -e

PROFILE_DIR="results/profiling/complete"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
OUTPUT_DIR="$PROFILE_DIR/$TIMESTAMP"

echo "=== Complete Performance Profiling ==="
echo "Output: $OUTPUT_DIR"

mkdir -p "$OUTPUT_DIR"

# 1. CPU –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
echo "üî• CPU Profiling..."
go test -bench=. -benchtime=30s -cpuprofile="$OUTPUT_DIR/cpu_queue.prof" ./internal/queue
go test -bench=. -benchtime=30s -cpuprofile="$OUTPUT_DIR/cpu_processor.prof" ./internal/processor
go test -bench=. -benchtime=30s -cpuprofile="$OUTPUT_DIR/cpu_client.prof" ./internal/client

# 2. Memory –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
echo "üß† Memory Profiling..."
go test -bench=. -benchtime=30s -memprofile="$OUTPUT_DIR/mem_queue.prof" ./internal/queue
go test -bench=. -benchtime=30s -memprofile="$OUTPUT_DIR/mem_processor.prof" ./internal/processor

# 3. Block –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ (–∫–æ–Ω–∫—É—Ä–µ–Ω—Ü–∏—è)
echo "üîí Block Profiling..."
go test -bench=. -benchtime=10s -blockprofile="$OUTPUT_DIR/block_queue.prof" ./internal/queue

# 4. Mutex –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
echo "üîê Mutex Profiling..."
go test -bench=. -benchtime=10s -mutexprofile="$OUTPUT_DIR/mutex_processor.prof" ./internal/processor

# 5. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–æ–≤
echo "üìä Generating reports..."

# CPU hot paths
go tool pprof -top -nodecount=20 "$OUTPUT_DIR/cpu_queue.prof" > "$OUTPUT_DIR/cpu_queue_top.txt"
go tool pprof -top -nodecount=20 "$OUTPUT_DIR/cpu_processor.prof" > "$OUTPUT_DIR/cpu_processor_top.txt"

# Memory allocations
go tool pprof -top -alloc_space "$OUTPUT_DIR/mem_queue.prof" > "$OUTPUT_DIR/mem_queue_allocs.txt"

# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è flame graphs
echo "üî• Generating flame graphs..."
go tool pprof -svg "$OUTPUT_DIR/cpu_queue.prof" > "$OUTPUT_DIR/cpu_queue_flame.svg"
go tool pprof -svg "$OUTPUT_DIR/cpu_processor.prof" > "$OUTPUT_DIR/cpu_processor_flame.svg"

echo "‚úÖ Profiling complete!"
```

#### 6.3 –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤—ã—è–≤–ª–µ–Ω–Ω—ã—Ö hot paths

**–§–∞–π–ª**: `internal/queue/memory_queue_optimized.go`

```go
package queue

import (
    "context"
    "sync"
    
    "github.com/stsolovey/diplom-distributed-system/internal/models"
)

// –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å object pool
var messagePool = sync.Pool{
    New: func() interface{} {
        return &models.DataMessage{
            Metadata: make(map[string]string),
        }
    },
}

// OptimizedMemoryQueue - –≤–µ—Ä—Å–∏—è —Å –ø—É–ª–æ–º –æ–±—ä–µ–∫—Ç–æ–≤
type OptimizedMemoryQueue struct {
    messages chan *models.DataMessage
    mu       sync.RWMutex
    closed   bool
    stats    Stats
}

func NewOptimizedMemoryQueue(size int) *OptimizedMemoryQueue {
    return &OptimizedMemoryQueue{
        messages: make(chan *models.DataMessage, size),
    }
}

func (q *OptimizedMemoryQueue) Publish(ctx context.Context, msg *models.DataMessage) error {
    // –ö–æ–ø–∏—Ä—É–µ–º –≤ –æ–±—ä–µ–∫—Ç –∏–∑ –ø—É–ª–∞
    pooledMsg := messagePool.Get().(*models.DataMessage)
    pooledMsg.Id = msg.Id
    pooledMsg.Timestamp = msg.Timestamp
    pooledMsg.Source = msg.Source
    pooledMsg.Payload = append(pooledMsg.Payload[:0], msg.Payload...)
    
    // –ö–æ–ø–∏—Ä—É–µ–º metadata
    for k, v := range msg.Metadata {
        pooledMsg.Metadata[k] = v
    }
    
    select {
    case q.messages <- pooledMsg:
        q.mu.Lock()
        q.stats.TotalEnqueued++
        q.mu.Unlock()
        return nil
    case <-ctx.Done():
        messagePool.Put(pooledMsg)
        return ctx.Err()
    default:
        messagePool.Put(pooledMsg)
        return ErrQueueFull
    }
}
```

### –®–∞–≥ 7: –°–µ—Ç–µ–≤—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

#### 7.1 –†–µ–∞–ª–∏–∑–∞—Ü–∏—è gRPC endpoint

**–§–∞–π–ª**: `api/proto/service.proto`

```protobuf
syntax = "proto3";

package diplom.v1;

option go_package = "github.com/stsolovey/diplom-distributed-system/internal/grpc";

service IngestService {
    rpc Ingest(IngestRequest) returns (IngestResponse);
    rpc IngestStream(stream IngestRequest) returns (IngestResponse);
}

message IngestRequest {
    string source = 1;
    bytes data = 2;
    map<string, string> metadata = 3;
}

message IngestResponse {
    string message_id = 1;
    string status = 2;
}
```

**–§–∞–π–ª**: `internal/grpc/server.go`

```go
package grpc

import (
    "context"
    "fmt"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    
    "github.com/google/uuid"
    "github.com/stsolovey/diplom-distributed-system/internal/client"
    "github.com/stsolovey/diplom-distributed-system/internal/models"
)

type IngestServer struct {
    UnimplementedIngestServiceServer
    processorClient *client.ProcessorClient
}

func NewIngestServer(processorURL string) *IngestServer {
    return &IngestServer{
        processorClient: client.NewProcessorClient(processorURL),
    }
}

func (s *IngestServer) Ingest(ctx context.Context, req *IngestRequest) (*IngestResponse, error) {
    msg := &models.DataMessage{
        Id:        uuid.New().String(),
        Timestamp: time.Now().Unix(),
        Source:    req.Source,
        Payload:   req.Data,
        Metadata:  req.Metadata,
    }
    
    if err := s.processorClient.SendMessage(ctx, msg); err != nil {
        return nil, status.Errorf(codes.Internal, "failed to process: %v", err)
    }
    
    return &IngestResponse{
        MessageId: msg.Id,
        Status:    "accepted",
    }, nil
}

func (s *IngestServer) IngestStream(stream IngestService_IngestStreamServer) error {
    var processed int32
    
    for {
        req, err := stream.Recv()
        if err == io.EOF {
            return stream.SendAndClose(&IngestResponse{
                MessageId: fmt.Sprintf("batch-%d", processed),
                Status:    "completed",
            })
        }
        if err != nil {
            return err
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–∫ –≤ Ingest
        // ...
        processed++
    }
}
```

**–§–∞–π–ª**: `cmd/grpc-gateway/main.go`

```go
package main

import (
    "log"
    "net"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/reflection"
    
    pb "github.com/stsolovey/diplom-distributed-system/internal/grpc"
)

func main() {
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("Failed to listen: %v", err)
    }
    
    s := grpc.NewServer(
        grpc.MaxRecvMsgSize(10 * 1024 * 1024), // 10MB
        grpc.MaxSendMsgSize(10 * 1024 * 1024),
    )
    
    ingestServer := pb.NewIngestServer(getProcessorURL())
    pb.RegisterIngestServiceServer(s, ingestServer)
    
    // –í–∫–ª—é—á–∞–µ–º reflection –¥–ª—è grpcurl
    reflection.Register(s)
    
    log.Printf("gRPC server starting on :50051")
    if err := s.Serve(lis); err != nil {
        log.Fatalf("Failed to serve: %v", err)
    }
}
```

#### 7.2 –î–æ–±–∞–≤–ª–µ–Ω–∏–µ HTTP/2

**–§–∞–π–ª**: `cmd/api-gateway/main.go` (–º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è)

```go
import (
    "golang.org/x/net/http2"
    "golang.org/x/net/http2/h2c"
)

func main() {
    // ... existing code ...
    
    // –°–æ–∑–¥–∞–µ–º HTTP/2 —Å–µ—Ä–≤–µ—Ä
    h2s := &http2.Server{
        MaxHandlers:                  0,
        MaxConcurrentStreams:         250,
        MaxReadFrameSize:             1 << 20,
        PermitProhibitedCipherSuites: false,
        IdleTimeout:                  120 * time.Second,
    }
    
    // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º handler –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ HTTP/2 –±–µ–∑ TLS
    handler := h2c.NewHandler(loggingMiddleware(mux), h2s)
    
    srv := &http.Server{
        Addr:              ":" + cfg.APIPort,
        Handler:           handler,
        ReadTimeout:       5 * time.Second,
        WriteTimeout:      5 * time.Second,
        IdleTimeout:       120 * time.Second,
        MaxHeaderBytes:    1 << 20,
        ReadHeaderTimeout: 2 * time.Second,
    }
    
    log.Printf("API Gateway starting on port %s with HTTP/2 support", cfg.APIPort)
    // ...
}
```

#### 7.3 –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è Connection Pooling

**–§–∞–π–ª**: `internal/client/optimized_client.go`

```go
package client

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "net"
    "net/http"
    "sync"
    "time"
    
    "golang.org/x/net/http2"
)

// OptimizedProcessorClient —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º connection pooling
type OptimizedProcessorClient struct {
    baseURL    string
    httpClient *http.Client
    bufferPool *sync.Pool
}

func NewOptimizedProcessorClient(baseURL string) *OptimizedProcessorClient {
    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç —Å HTTP/2
    transport := &http.Transport{
        Proxy: http.ProxyFromEnvironment,
        DialContext: (&net.Dialer{
            Timeout:   30 * time.Second,
            KeepAlive: 30 * time.Second,
            DualStack: true,
        }).DialContext,
        ForceAttemptHTTP2:     true,
        MaxIdleConns:          1000,
        MaxIdleConnsPerHost:   200,
        MaxConnsPerHost:       200,
        IdleConnTimeout:       90 * time.Second,
        TLSHandshakeTimeout:   10 * time.Second,
        ExpectContinueTimeout: 1 * time.Second,
        DisableCompression:    true, // –û—Ç–∫–ª—é—á–∞–µ–º –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
    }
    
    // –Ø–≤–Ω–æ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º HTTP/2
    if err := http2.ConfigureTransport(transport); err != nil {
        log.Printf("Failed to configure HTTP/2: %v", err)
    }
    
    return &OptimizedProcessorClient{
        baseURL: baseURL,
        httpClient: &http.Client{
            Timeout:   2 * time.Second,
            Transport: transport,
        },
        bufferPool: &sync.Pool{
            New: func() interface{} {
                return new(bytes.Buffer)
            },
        },
    }
}

func (c *OptimizedProcessorClient) SendMessage(ctx context.Context, msg *models.DataMessage) error {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º buffer pool
    buf := c.bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        c.bufferPool.Put(buf)
    }()
    
    // –≠–Ω–∫–æ–¥–∏–º –Ω–∞–ø—Ä—è–º—É—é –≤ buffer
    encoder := json.NewEncoder(buf)
    if err := encoder.Encode(msg); err != nil {
        return fmt.Errorf("failed to encode: %w", err)
    }
    
    req, err := http.NewRequestWithContext(
        ctx,
        http.MethodPost,
        c.baseURL+"/enqueue",
        bytes.NewReader(buf.Bytes()),
    )
    if err != nil {
        return fmt.Errorf("failed to create request: %w", err)
    }
    
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Connection", "keep-alive")
    
    resp, err := c.httpClient.Do(req)
    if err != nil {
        return fmt.Errorf("failed to send: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusAccepted {
        return fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    // –î—Ä–µ–Ω–∏—Ä—É–µ–º body –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    io.Copy(io.Discard, resp.Body)
    
    return nil
}
```

#### 7.4 –ò–∑–º–µ—Ä–µ–Ω–∏–µ latency —Å httptrace

**–§–∞–π–ª**: `internal/client/traced_client.go`

```go
package client

import (
    "context"
    "log"
    "net/http/httptrace"
    "time"
)

type LatencyMetrics struct {
    DNSLookup        time.Duration
    TCPConnection    time.Duration
    TLSHandshake     time.Duration
    ServerProcessing time.Duration
    Total            time.Duration
}

func (c *OptimizedProcessorClient) SendMessageWithTrace(
    ctx context.Context, 
    msg *models.DataMessage,
) (*LatencyMetrics, error) {
    metrics := &LatencyMetrics{}
    var start time.Time
    
    trace := &httptrace.ClientTrace{
        DNSStart: func(info httptrace.DNSStartInfo) {
            start = time.Now()
        },
        DNSDone: func(info httptrace.DNSDoneInfo) {
            metrics.DNSLookup = time.Since(start)
        },
        ConnectStart: func(network, addr string) {
            start = time.Now()
        },
        ConnectDone: func(network, addr string, err error) {
            metrics.TCPConnection = time.Since(start)
        },
        TLSHandshakeStart: func() {
            start = time.Now()
        },
        TLSHandshakeDone: func(state tls.ConnectionState, err error) {
            metrics.TLSHandshake = time.Since(start)
        },
        GotFirstResponseByte: func() {
            metrics.ServerProcessing = time.Since(start)
        },
    }
    
    ctx = httptrace.WithClientTrace(ctx, trace)
    totalStart := time.Now()
    
    err := c.SendMessage(ctx, msg)
    metrics.Total = time.Since(totalStart)
    
    return metrics, err
}
```

**–§–∞–π–ª**: `cmd/api-gateway/trace_endpoint.go`

```go
package main

import (
    "encoding/json"
    "net/http"
    
    "github.com/stsolovey/diplom-distributed-system/internal/client"
)

func handleTrace(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    msg := &models.DataMessage{
        Id:      "trace-test",
        Source:  "trace-endpoint",
        Payload: []byte("latency measurement"),
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å —Ç—Ä–µ–π—Å–∏–Ω–≥–æ–º
    client := client.NewOptimizedProcessorClient(getProcessorURL())
    metrics, err := client.SendMessageWithTrace(r.Context(), msg)
    
    response := map[string]interface{}{
        "success": err == nil,
        "latency": map[string]string{
            "dns_lookup":        metrics.DNSLookup.String(),
            "tcp_connection":    metrics.TCPConnection.String(),
            "tls_handshake":     metrics.TLSHandshake.String(),
            "server_processing": metrics.ServerProcessing.String(),
            "total":             metrics.Total.String(),
        },
    }
    
    if err != nil {
        response["error"] = err.Error()
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}
```

#### 7.5 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Makefile

```makefile
# –î–æ–±–∞–≤–∏—Ç—å –≤ Makefile

.PHONY: proto-grpc
proto-grpc:
	protoc --go_out=. --go_opt=paths=source_relative \
		--go-grpc_out=. --go-grpc_opt=paths=source_relative \
		api/proto/service.proto

.PHONY: build-grpc
build-grpc: proto-grpc
	go build -o bin/grpc-gateway cmd/grpc-gateway/main.go

.PHONY: profile-complete
profile-complete:
	./scripts/complete_profiling.sh

.PHONY: test-optimizations
test-optimizations:
	@echo "Testing HTTP/2..."
	curl -v --http2-prior-knowledge http://localhost:8080/health
	@echo "\nTesting gRPC..."
	grpcurl -plaintext localhost:50051 list
	@echo "\nTesting trace endpoint..."
	curl http://localhost:8080/api/v1/trace | jq .
```

## üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–æ–∑–¥–∞–≤–∞–µ–º—ã—Ö —Ñ–∞–π–ª–æ–≤

```
internal/
‚îú‚îÄ‚îÄ grpc/
‚îÇ   ‚îú‚îÄ‚îÄ server.go
‚îÇ   ‚îî‚îÄ‚îÄ service.pb.go (generated)
‚îú‚îÄ‚îÄ client/
‚îÇ   ‚îú‚îÄ‚îÄ optimized_client.go
‚îÇ   ‚îî‚îÄ‚îÄ traced_client.go
‚îî‚îÄ‚îÄ queue/
    ‚îî‚îÄ‚îÄ memory_queue_optimized.go

cmd/
‚îú‚îÄ‚îÄ grpc-gateway/
‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îî‚îÄ‚îÄ api-gateway/
    ‚îú‚îÄ‚îÄ main.go (modified)
    ‚îî‚îÄ‚îÄ trace_endpoint.go

scripts/
‚îî‚îÄ‚îÄ complete_profiling.sh

api/proto/
‚îî‚îÄ‚îÄ service.proto
```

## ‚úÖ Definition of Done –¥–ª—è –§–∞–∑—ã 3

### –®–∞–≥ 6 - –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ:
- [ ] BenchmarkWorkerPool —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è
- [ ] –í—Å–µ benchmarks –ø—Ä–æ—Ö–æ–¥—è—Ç –±–µ–∑ –æ—à–∏–±–æ–∫
- [ ] CPU –ø—Ä–æ—Ñ–∏–ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
- [ ] Memory –ø—Ä–æ—Ñ–∏–ª–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
- [ ] Hot paths –∏–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω—ã –∏ –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã
- [ ] Flame graphs —Å–æ–∑–¥–∞–Ω—ã
- [ ] Object pool —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –¥–ª—è DataMessage

### –®–∞–≥ 7 - –°–µ—Ç–µ–≤—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:
- [ ] gRPC —Å–µ—Ä–≤–µ—Ä —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ :50051
- [ ] HTTP/2 –≤–∫–ª—é—á–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç (–ø—Ä–æ–≤–µ—Ä–µ–Ω–æ curl --http2-prior-knowledge)
- [ ] Connection pooling –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω (200 connections per host)
- [ ] httptrace endpoint —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ latency
- [ ] Buffer pools –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è JSON encoding
- [ ] –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç

### –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:
- [ ] `docs/profiling/PHASE3_COMPLETE.md` —Å–æ–∑–¥–∞–Ω —Å –∏—Ç–æ–≥–∞–º–∏
- [ ] README.md –æ–±–Ω–æ–≤–ª–µ–Ω —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ gRPC endpoint
- [ ] Makefile —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –Ω–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã

## üìä –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –§–∞–∑—ã 3:
- Benchmarks –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç —É–ª—É—á—à–µ–Ω–∏–µ –Ω–∞ 20-50%
- Memory allocations —É–º–µ–Ω—å—à–µ–Ω—ã –Ω–∞ 30%+
- HTTP/2 –∏ gRPC endpoints —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—Ä—É—é—Ç
- Connection reuse > 80%
- –°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ –Ω–∞–≥—Ä—É–∑–æ—á–Ω–æ–º—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é –≤ –§–∞–∑–µ 4

## ‚è∞ –ì—Ä–∞—Ñ–∏–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

### –î–µ–Ω—å 1 (4-5 ):
1. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ BenchmarkWorkerPool 
2. –ü–æ–ª–Ω–æ–µ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ 
3. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è object pool 
4. gRPC implementation -

### –î–µ–Ω—å 2 (4-5 ):
1. HTTP/2 –≤–∫–ª—é—á–µ–Ω–∏–µ 
2. Connection pooling –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 
3. httptrace implementation 
4. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π 
5. –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ 

**–û–±—â–µ–µ –≤—Ä–µ–º—è**: 8-10 

## üöÄ –ö–æ–º–∞–Ω–¥–∞ –∑–∞–ø—É—Å–∫–∞ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è

```bash
# –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏
make docker-build
QUEUE_TYPE=memory make docker-up

# –í –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ç–µ—Ä–º–∏–Ω–∞–ª–µ - gRPC gateway
./bin/grpc-gateway

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç—ã
make test-optimizations
```